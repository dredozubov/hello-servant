#+AUTHOR:    Denis Redozubov, @rufuse
#+EMAIL:     @rufuse
#+TITLE:     Делаем свою жизнь проще c Servant
#+OPTIONS:   H:2 num:t toc:nil \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+STARTUP: beamer
#+STARTUP: latexpreview
#+BEAMER_THEME: Singapore [height=20pt]
#+BEAMER_COLOR_THEME: crane
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[russian]{babel}
#+LATEX_HEADER: \usepackage[T2A]{fontenc}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usetikzlibrary{matrix}
#+LATEX_HEADER: \newminted{haskell}{}
#+LATEX_HEADER: \usemintedstyle{monokai}
#+LATEX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [unicode,presentation,bigger]

* Слайды и код
  
** Слайды и код

https://github.com/dredozubov/hello-servant/tree/ruhaskell

* Основы Servant

** Минимальный сервер

#+BEGIN_SRC haskell
type API = "42" :> Get '[JSON] Int

apiHandler = return 42

api :: Proxy API
api = Proxy

main = run 8080 (serve api apiHandler)
#+END_SRC

** Почему Servant?

- четкое распределение ролей
- type safety
- Способ объединить API для серверов, клиентов, документации

** Как мы используем servant

- http сервера (1)
- Генерация мок-серверов для теста соединения между сервером и клиентом
- Сгенерированные клиенты
- (1) возможно использовать как subsite в др. фреймворках(e.g. Yesod)
- (+ Мы любим type safety)

** Что такое описание API?

#+BEGIN_SRC haskell
-- получить все заказы
"/order" - GET
-- получить один заказ
"/order/:order_id/" - GET
-- добавить один заказ
"/order" - PUT / Request 'application/json'
         with Order object(see schema)
-- добавить платеж к заказу
"/order/:order_id/payment" - GET
#+END_SRC

** API можно описать с помощью языка программирования

#+BEGIN_SRC haskell
api = Get "order" orders
  <|> Put "order" order
  <|> Get "order/:id" order
  <|> Get "order/:id/payment" payments
#+END_SRC

** Отступление 1: Моноиды

#+BEGIN_SRC haskell
-- Laws:
-- a <> mempty = a
-- mempty <> a = a
-- a <> (b <> c) = (a <> b) <> c
class Monoid a where
  mempty      :: a
  a <> b :: a -> a -> a

instance [] a where
  mempty  = []
  (<>) = (++)
#+END_SRC

** Отступление 2: Alternative

#+BEGIN_SRC haskell
-- Laws:
-- a <|> empty = a
-- empty <|> a = a
-- a <|> (b <|> c) = (a <|> b) <|> c
class Applicative f => Alternative a where
  empty   :: a
  x <|> y :: a -> a -> a

data Maybe a = Just a | Nothing

instance Alternative Maybe where
  empty = Nothing
  Nothing <|> r = r
  l       <|> _ = l
#+END_SRC

** API возможно комбинировать из частей

#+BEGIN_SRC haskell
getOrderAPI = Get "order"
  `respondsWith` (jsonOf orders)

addOrderAPI = Put "order"
  `takes` (jsonOf order)
  `respondsWith` (jsonOf id)

-- это может быть частью большего API или роутера!
orderAPI = getOrderAPI <|> addOrderAPI
#+END_SRC

** API это тип в servant

#+BEGIN_SRC haskell
type API = "order" :> Get '[JSON] [Order]
      :<|> "order" :> Capture "order_id" Int
                   :> Get '[JSON] Order
      :<|> "order" :> ReqBody '[JSON] Order
                   :> Put '[JSON] Int
      :<|> "order"
        :> Capture "from_params"
        :> QueryParam "first_name" FirstName
	:> QueryParam "last_name" LastName
	-- ...
        -- Остаток параметров опущен
        :> Put '[JSON] Int
#+END_SRC

** Сервер наследует сигнатуры хендлеров из API

#+BEGIN_SRC haskell
-- we have only types here
getOrders :: Server [Order]

getOrder :: Int -> Server Order

addOrder :: Order -> Server Int

addOrderFromParams :: FirstName
                   -> LastName
                   -> ...
                   ...
                   -> Server Int
#+END_SRC

** Что мы можем "извлечь" из API?

- хендлеры для серверов
- полный haskell-клиент
- тонкие js/ruby/etc клиенты
- mock-сервера


* Взгляд в будущее

** servant-0.5

- auth комбинаторы - basic auth и JWT support
- улучшенные роутеры с `Delayed` проверками и пр.
- servant-foreign - универсальный бэкенд для генерации кода на других языках
- обязательные query params

** Варианты интеграций

- API Blueprint
- Swagger
- JSON Schema

** Проекты стоящие упоминания

- servant-swagger
- verdict

* live coding

** План действий

- обзор backend
- определяем API
- конструируем CRUD server
- "выводим" клиент на haskell
- генерация js-клиента
- реализуем mock server

* Прочее

** Implementation

Статья про имплементацию servant:

http://www.well-typed.com/blog/2015/11/implementing-a-minimal-version-of-haskell-servant/

** contacts

- http://twitter.com/rufuse (@rufuse)
- http://bananasandlenses.net Подкаст "Бананы и линзы"
